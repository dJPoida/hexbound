import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

declare let self: ServiceWorkerGlobalScope;

// When the new service worker is installed, this message listener will prompt it to activate immediately.
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Precache all the assets generated by the build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present in the service worker file.
precacheAndRoute(self.__WB_MANIFEST);

// Remove old caches.
cleanupOutdatedCaches();

// Example of caching an API route (GET requests only)
registerRoute(
  ({ request, url }) => request.method === 'GET' && url.pathname.startsWith('/api'),
  new StaleWhileRevalidate()
);

self.addEventListener('push', (event: PushEvent) => {
  const showNotification = async () => {
    // Check for visible clients
    const allClients = await self.clients.matchAll({
      includeUncontrolled: true,
      type: 'window',
    });

    const isAppVisible = allClients.some((client) => client.visibilityState === 'visible');

    if (isAppVisible) {
      console.log('[SW] Push event received, but a client is visible. Skipping notification.');
      return;
    }

    if (!event.data) {
      console.error('Push event but no data');
      return;
    }
    
    const data = event.data.json();
    const title = data.title || 'Hexbound';
    const options = {
      body: data.body || 'You have a new notification.',
      icon: '/favicon/android-chrome-192x192.png', // Optional
      badge: '/favicon/favicon-32x32.png', // Optional
      data: data.data, // Attach custom data
    };

    await self.registration.showNotification(title, options);
  };

  event.waitUntil(showNotification());
});

self.addEventListener('notificationclick', (event: NotificationEvent) => {
  console.log('[SW] Notification click received.', event.notification.data);
  
  event.notification.close();

  const openGamePromise = async () => {
    const gameId = event.notification.data?.gameId;
    const gameUrl = gameId ? `/game/${gameId}` : '/';
    
    const allClients = await self.clients.matchAll({
      includeUncontrolled: true,
      type: 'window',
    });

    // Find a client to focus, preferably one that is already visible.
    const clientToFocus = allClients.find(client => client.visibilityState === 'visible') || allClients[0];

    if (clientToFocus) {
      console.log('[SW] Found an existing app window. Focusing and navigating.');
      // Note: client.navigate() is not supported in all browsers.
      // It's best to check for its existence.
      if ('navigate' in clientToFocus && typeof clientToFocus.navigate === 'function') {
        await clientToFocus.navigate(gameUrl);
      }
      return clientToFocus.focus();
    } else {
      console.log(`[SW] No existing window found. Opening new one at ${gameUrl}`);
      return self.clients.openWindow(gameUrl);
    }
  };

  event.waitUntil(openGamePromise());
});

// The manual fetch handler has been removed, as it can conflict with Workbox's precaching. 